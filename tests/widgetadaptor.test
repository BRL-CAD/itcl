#---------------------------------------------------------------------
# TITLE:
#       typefunction.test
#
# AUTHOR:
#       Arnulf Wiedemann with a lot of code form the snit tests by
#       Will Duquette
#
# DESCRIPTION:
#       Test cases for ::itcl::type proc, method, typemethod commands.
#       Uses the ::tcltest:: harness.
#
#       There is at least Tcl 8.6a3 needed
#
#    The tests assume tcltest 2.2
#-----------------------------------------------------------------------

# ### ### ### ######### ######### #########
## Declare the minimal version of Tcl required to run the package
## tested by this testsuite, and its dependencies.

proc testsNeedTcl {version} {
    # This command ensures that a minimum version of Tcl is used to
    # run the tests in the calling testsuite. If the minimum is not
    # met by the active interpreter we forcibly bail out of the
    # testsuite calling the command. The command has to be called
    # immediately after loading the utilities.

    if {[package vsatisfies [package provide Tcl] $version]} return

    puts "    Aborting the tests found in \"[file tail [info script]]\""
    puts "    Requiring at least Tcl $version, have [package present Tcl]."

    # This causes a 'return' in the calling scope.
    return -code return
}

# ### ### ### ######### ######### #########
## Declare the minimum version of Tcltest required to run the
## testsuite.

proc testsNeedTcltest {version} {
    # This command ensure that a minimum version of the Tcltest
    # support package is used to run the tests in the calling
    # testsuite. If the minimum is not met by the loaded package we
    # forcibly bail out of the testsuite calling the command. The
    # command has to be called after loading the utilities. The only
    # command allowed to come before it is 'textNeedTcl' above.

    # Note that this command will try to load a suitable version of
    # Tcltest if the package has not been loaded yet.

    if {[lsearch [namespace children] ::tcltest] == -1} {
	if {![catch {
	    package require tcltest $version
	}]} {
	    namespace import -force ::tcltest::*
	    return
	}
    } elseif {[package vcompare [package present tcltest] $version] >= 0} {
	return
    }

    puts "    Aborting the tests found in [file tail [info script]]."
    puts "    Requiring at least tcltest $version, have [package present tcltest]"

    # This causes a 'return' in the calling scope.
    return -code return
}

# Set up for Tk tests: enter the event loop long enough to catch
# any bgerrors.
proc tkbide {{msg "tkbide"} {msec 500}} {
    set ::bideVar 0
    set ::bideError ""
    set ::bideErrorInfo ""
    # It looks like update idletasks does the job.
    if {0} {
        after $msec {set ::bideVar 1}
        tkwait variable ::bideVar
    }
    update idletasks
    if {"" != $::bideError} {
        error "$msg: $::bideError" $::bideErrorInfo
    }
}



testsNeedTcl     8.6
testsNeedTcltest 2.2

interp alias {} type {} ::itcl::type
interp alias {} widgetadaptor {} ::itcl::widgetadaptor

package require Tk 8.6

# Marks tests which are only for Tk.
tcltest::testConstraint tk [info exists tk_version]

::tcltest::loadTestedCommands

if {1} {
#-----------------------------------------------------------------------
# Widgetadaptors

test widgetadaptor-1.1 {creating a widget: hull hijacking} -constraints {
    tk
} -body {
    widgetadaptor mylabel {
        constructor {args} {
            installhull [label ${self}l]
            $self configure {*}$args
        }

        delegate method * to itcl_hull
        delegate option * to itcl_hull
    }

    set xx [mylabel create .label -text "My Label"]

    set a [.label cget -text]
    set b [::itcl::widget::internal::hull1.label cget -text]

    destroy .label
    tkbide
    list $a $b
} -cleanup {
    mylabel destroy
} -result {{My Label} {My Label}}

test widgetadaptor-1.2 {destroying a widget with destroy} -constraints {
    tk
} -body {
    widgetadaptor mylabel {
        constructor {} {
            installhull [label ${self}l]
        }
    }

    mylabel create .label
    set a [namespace children ::itcl::internal::variables]
    destroy .label
    set b [namespace children ::itcl::internal::variables]
    tkbide
    list $a $b
} -cleanup {
    mylabel destroy
} -result {{::itcl::internal::variables::.label ::itcl::internal::variables::mylabel} {::itcl::internal::variables::.label ::itcl::internal::variables::mylabel}}

test widgetadaptor-1.3 {destroying two widgets of the same type with destroy} -constraints {
    tk
} -body {
    widgetadaptor mylabel {
        constructor {} {
            installhull [label ${self}l]
        }
    }

    mylabel create .lab1
    mylabel create .lab2
    set a [namespace children ::itcl::internal::variables]
    destroy .lab1
    destroy .lab2
    set b [namespace children ::itcl::internal::variables]
    tkbide
    list $a $b
} -cleanup {
    mylabel destroy
} -result {{::itcl::internal::variables::.lab1 ::itcl::internal::variables::mylabel ::itcl::internal::variables::.lab2} {::itcl::internal::variables::.lab1 ::itcl::internal::variables::mylabel ::itcl::internal::variables::.lab2}}

test widgetadaptor-1.4 {destroying a widget with rename, then destroy type} -body {
    widgetadaptor mylabel {
        constructor {} {
            installhull [label ${self}l]
        }
    }

    mylabel create .label
    set a [namespace children ::itcl::internal::variables]
    rename .label ""
    set b [namespace children ::itcl::internal::variables]

    mylabel destroy
    tkbide
    list $a $b
} -result {{::itcl::internal::variables::.label ::itcl::internal::variables::mylabel} ::itcl::internal::variables::mylabel}

test widgetadaptor-1.5 {destroying two widgets of the same type with rename} -body {
    widgetadaptor mylabel {
        constructor {} {
            installhull [label ${self}l]
        }
    }

    mylabel create .lab1
    mylabel create .lab2
    set a [namespace children ::itcl::internal::variables]
    rename .lab1 ""
    rename .lab2 ""
    set b [namespace children ::itcl::internal::variables]
    mylabel destroy
    tkbide
    list $a $b
} -result {{::itcl::internal::variables::.lab1 ::itcl::internal::variables::mylabel ::itcl::internal::variables::.lab2} ::itcl::internal::variables::mylabel}

test widgetadaptor-1.6 {create/destroy twice, with destroy} -constraints {
    tk
} -body {
    widgetadaptor mylabel {
        constructor {} {
            installhull [label ${self}l]
        }
    }

    mylabel create .lab1
    set a [namespace children ::itcl::internal::variables]
    destroy .lab1

    mylabel create .lab1
    set b [namespace children ::itcl::internal::variables]
    destroy .lab1

    set c [namespace children ::itcl::internal::variables]
    mylabel destroy
    tkbide
    list $a $b $c
} -result {{::itcl::internal::variables::.lab1 ::itcl::internal::variables::mylabel} {::itcl::internal::variables::.lab1 ::itcl::internal::variables::mylabel} {::itcl::internal::variables::.lab1 ::itcl::internal::variables::mylabel}}

test widgetadaptor-1.7 {create/destroy twice, with rename} -body {
    widgetadaptor mylabel {
        constructor {} {
            installhull [label ${self}l]
        }
    }

    mylabel create .lab1
    set a [namespace children ::itcl::internal::variables]
    rename .lab1 ""

    mylabel create .lab1
    set b [namespace children ::itcl::internal::variables]
    rename .lab1 ""

    set c [namespace children ::itcl::internal::variables]
    mylabel destroy
    tkbide
    list $a $b $c
} -result {{::itcl::internal::variables::.lab1 ::itcl::internal::variables::mylabel} {::itcl::internal::variables::.lab1 ::itcl::internal::variables::mylabel} ::itcl::internal::variables::mylabel}

test widgetadaptor-1.8 {"create" is optional} -constraints {
    tk
} -body {
    widgetadaptor mylabel {
        constructor {args} {
            installhull [label ${self}l]
        }
        method howdy {} {return "Howdy!"}
    }

    mylabel .label
    set a [.label howdy]

    destroy .label
    tkbide
    set a
} -cleanup {
    mylabel destroy
} -result {Howdy!}

test widgetadaptor-1.10 {"create" is optional, but must be a valid name} -constraints {
    tk
} -body {
    widgetadaptor mylabel {
        constructor {args} {
            installhull [label ${self}l]
        }
        method howdy {} {return "Howdy!"}
    }

    catch {mylabel foo} result
    tkbide
    set result
} -cleanup {
    mylabel destroy
} -result {bad window path name "fool"}

test widgetadaptor-1.11 {user-defined destructors are called} -constraints {
    tk
} -body {
    widgetadaptor mylabel {
        typevariable flag ""

        constructor {args} {
            installhull [label ${self}l]
            set flag "created $self"
        }

        destructor {
puts stderr "DEST CALLED"
            set flag "destroyed $self"
        }

        typemethod getflag {} {
            return $flag
        }
    }

    mylabel .label
    set a [mylabel getflag]
    destroy .label
    tkbide
    list $a [mylabel getflag]
} -cleanup {
    mylabel destroy
} -result {{created .label} {destroyed .label}}

test widgetadaptor-1.13 {destroy method not defined for widget types} -constraints {
    tk
} -body {
    widgetadaptor mylabel {
        constructor {args} {
            installhull [label ${self}l]
        }
    }

    mylabel .label
    catch {.label destroy} result
    destroy .label
    tkbide
    set result
} -cleanup {
    mylabel destroy
} -result {unknown subcommand "destroy": namespace ::mylabel::Snit_inst1 does not export any commands}

test widgetadaptor-1.14 {hull can be repeatedly renamed} -constraints {
    tk
} -body {
    widgetadaptor basetype {
        constructor {args} {
            installhull [label ${self}l]
        }

        method basemethod {} { return "basemethod" }
    }

    widgetadaptor w1 {
        constructor {args} {
            installhull [basetype create ${self}l2]
        }
    }

    widgetadaptor w2 {
        constructor {args} {
            installhull [w1 ${self}l3]
        }
    }

    set a [w2 .foo]
    destroy .foo
    tkbide
    set a
} -cleanup {
    w2 destroy
    w1 destroy
    basetype destroy
} -result {.foo}

test widgetadaptor-1.15 {widget names can be generated} -constraints {
    tk
} -body {
    widgetadaptor unique {
        constructor {args} {
            installhull [label ${self}l]
        }
    }

    set w [unique .#auto]
    destroy $w
    tkbide
    set w
} -cleanup {
    unique destroy
} -result {.unique0}

# end
}

test widgetadaptor-1.16 {snit::widgetadaptor as hull} -constraints {
    tk
} -body {
    widgetadaptor mylabel {
        constructor {args} {
            installhull [label ${self}l]
puts stderr "mylabel!self!$self!args!$args!"
	    if {[llength $args]} {
                $self configure {*}$args
	    }
        }
        method method1 {} {
            return "method1"
        }
        delegate option * to itcl_hull
    }

    widgetadaptor mylabel2 {
        constructor {args} {
puts stderr "mylabel2!self!$self!args!$args!"
            installhull [mylabel ${self}l2]
puts stderr "mylabel2 2!self!$self!args!$args!"
                $self configure {*}$args
        }
        method method2 {} {
puts stderr "ITCL_HULL!$itcl_hull!"
            return "method2: [::itcl::widget::internal::hull1.label method1]"
#            return "method2: [$itcl_hull method1]"
        }
        delegate option * to itcl_hull
    }

puts stderr 333
    mylabel2 .label -text "Some Text"
    set a [.label method2]
puts stderr "A!$a!"
    set b [.label cget -text]
    .label configure -text "More Text"
    set c [.label cget -text]
    set d [namespace children ::mylabel2]
    set e [namespace children ::mylabel]

    destroy .label

    set f [namespace children ::mylabel2]
    set g [namespace children ::mylabel]

    mylabel2 destroy
    mylabel destroy

    tkbide
    list $a $b $c $d $e $f $g
} -result {{method2: method1} {Some Text} {More Text} ::mylabel2::Snit_inst1 ::mylabel::Snit_inst1 {} {}}

if {1} {
test widgetadaptor-1.17 {snit::widgetadaptor as hull; use rename} -body {
    widgetadaptor mylabel {
        constructor {args} {
            installhull [label ${self}l]
            $self configure {*}$args
        }
        method method1 {} {
            return "method1"
        }
        delegate option * to itcl_hull
    }

    widgetadaptor mylabel2 {
        constructor {args} {
            installhull [mylabel ${self}l]
            $self configure {*}$args
        }
        method method2 {} {
            return "method2: [$itcl_hull method1]"
        }
        delegate option * to itcl_hull
    }

    mylabel2 .label -text "Some Text"
    set a [.label method2]
    set b [.label cget -text]
    .label configure -text "More Text"
    set c [.label cget -text]
    set d [namespace children ::mylabel2]
    set e [namespace children ::mylabel]

    rename .label ""

    set f [namespace children ::mylabel2]
    set g [namespace children ::mylabel]

    mylabel2 destroy
    mylabel destroy

    tkbide
    list $a $b $c $d $e $f $g
} -result {{method2: method1} {Some Text} {More Text} ::mylabel2::Snit_inst1 ::mylabel::Snit_inst1 {} {}}

test widgetadaptor-1.18 {BWidget Label as hull} -constraints {
    bwidget
} -body {
    widgetadaptor mylabel {
        constructor {args} {
            installhull [Label $win]
            $self configure {*}$args
        }
        delegate option * to itcl_hull
    }

    mylabel .label -text "Some Text"
    set a [.label cget -text]

    .label configure -text "More Text"
    set b [.label cget -text]

    set c [namespace children ::mylabel]

    destroy .label

    set d [namespace children ::mylabel]

    mylabel destroy

    tkbide
    list $a $b $c $d
} -result {{Some Text} {More Text} ::mylabel::Snit_inst1 {}}

test widgetadaptor-1.19 {error in widgetadaptor constructor} -constraints {
    tk
} -body {
    widgetadaptor mylabel {
        constructor {args} {
            error "Simulated Error"
        }
    }

    mylabel .lab
} -returnCodes {
    error
} -cleanup {
    mylabel destroy
} -result {Error in constructor: Simulated Error}

#end
}

#---------------------------------------------------------------------
# Clean up

::tcltest::cleanupTests
return
