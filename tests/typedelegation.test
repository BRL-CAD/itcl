#---------------------------------------------------------------------
# TITLE:
#       typefunction.test
#
# AUTHOR:
#       Arnulf Wiedemann with a lot of code form the snit tests by
#       Will Duquette
#
# DESCRIPTION:
#       Test cases for ::itcl::type proc, method, typemethod commands.
#       Uses the ::tcltest:: harness.
#
#       There is at least Tcl 8.6a3 needed
#
#    The tests assume tcltest 2.2
#-----------------------------------------------------------------------

# ### ### ### ######### ######### #########
## Declare the minimal version of Tcl required to run the package
## tested by this testsuite, and its dependencies.

proc testsNeedTcl {version} {
    # This command ensures that a minimum version of Tcl is used to
    # run the tests in the calling testsuite. If the minimum is not
    # met by the active interpreter we forcibly bail out of the
    # testsuite calling the command. The command has to be called
    # immediately after loading the utilities.

    if {[package vsatisfies [package provide Tcl] $version]} return

    puts "    Aborting the tests found in \"[file tail [info script]]\""
    puts "    Requiring at least Tcl $version, have [package present Tcl]."

    # This causes a 'return' in the calling scope.
    return -code return
}

# ### ### ### ######### ######### #########
## Declare the minimum version of Tcltest required to run the
## testsuite.

proc testsNeedTcltest {version} {
    # This command ensure that a minimum version of the Tcltest
    # support package is used to run the tests in the calling
    # testsuite. If the minimum is not met by the loaded package we
    # forcibly bail out of the testsuite calling the command. The
    # command has to be called after loading the utilities. The only
    # command allowed to come before it is 'textNeedTcl' above.

    # Note that this command will try to load a suitable version of
    # Tcltest if the package has not been loaded yet.

    if {[lsearch [namespace children] ::tcltest] == -1} {
	if {![catch {
	    package require tcltest $version
	}]} {
	    namespace import -force ::tcltest::*
	    return
	}
    } elseif {[package vcompare [package present tcltest] $version] >= 0} {
	return
    }

    puts "    Aborting the tests found in [file tail [info script]]."
    puts "    Requiring at least tcltest $version, have [package present tcltest]"

    # This causes a 'return' in the calling scope.
    return -code return
}


testsNeedTcl     8.6
testsNeedTcltest 2.2

interp alias {} type {} ::itcl::type

::tcltest::loadTestedCommands

#-----------------------------------------------------------------------
# Typemethod delegation

test dtypemethod-1.1 {delegate typemethod to non-existent component} -body {
    set result ""

    type dog {
        delegate typemethod foo to bar
    }

    dog foo
} -returnCodes {
    error
} -result {::dog delegates typemethod "foo" to undefined typecomponent "bar"}

test dtypemethod-1.2 {delegating to existing typecomponent} -body {
    type dog {
        delegate typemethod length to string

        typeconstructor {
            set string string
        }
    }

    dog length foo
} -cleanup {
    dog destroy
} -result {3}

test dtypemethod-1.4 {delegating to existing typecomponent with error} -body {
    type dog {
        delegate typemethod length to string

        typeconstructor {
            set string string
        }
    }

    dog length foo bar
} -cleanup {
    dog destroy
} -returnCodes {
    error
} -result {wrong # args: should be "dog length string"}

test dtypemethod-1.5 {delegating unknown typemethods to existing typecomponent} -body {
    type dog {
        delegate typemethod * to string

        typeconstructor {
            set string string
        }
    }

    dog length foo
} -cleanup {
    dog destroy
} -result {3}

test dtypemethod-1.6a {delegating unknown typemethod to existing typecomponent with error} -body {
    type dog {
        delegate typemethod * to stringhandler

        typeconstructor {
            set stringhandler string
        }
    }

    dog foo bar
} -cleanup {
    dog destroy
} -returnCodes {
    error
} -result {unknown or ambiguous subcommand "foo": must be bytelength, compare, equal, first, index, is, last, length, map, match, range, repeat, replace, reverse, tolower, totitle, toupper, trim, trimleft, trimright, wordend, or wordstart}

test dtypemethod-1.7 {can't delegate local typemethod: order 1} -body {
    type dog {
        typemethod foo {} {}
        delegate typemethod foo to bar
    }
} -returnCodes {
    error
} -result {Error in "delegate typemethod foo...", "foo" has been defined locally.}

test dtypemethod-1.8 {can't delegate local typemethod: order 2} -body {
    type dog {
        delegate typemethod foo to bar
        typemethod foo {} {}
    }
} -returnCodes {
    error
} -result {Error in "typemethod foo...", "foo" has been delegated}

test dtypemethod-1.10 {excepted methods are caught properly} -body {
    type dog {
        delegate typemethod * to string except {match index}

        typeconstructor {
            set string string
        }
    }

    catch {dog length foo} a
    catch {dog match foo}  b
    catch {dog index foo}  c

    list $a $b $c
} -cleanup {
    dog destroy
} -result {3 {unknown subcommand "match": must be length} {unknown subcommand "index": must be length}}

test dtypemethod-1.11 {as clause can include arguments} -body {
    proc tail {a b} {
        return "<$a $b>"
    }

    type dog {
        delegate typemethod wag to tail as {wag briskly}

        typeconstructor {
            set tail tail
        }
    }

    dog wag
} -cleanup {
    dog destroy
    rename tail ""
} -result {<wag briskly>}

test dtypemethod-2.1 {'using "%c %m"' gets normal behavior} -body {
    type dog {
        delegate typemethod length to string using {%c %m}

        typeconstructor {
            set string string
        }
    }

    dog length foo
} -cleanup {
    dog destroy
} -result {3}

test dtypemethod-2.2 {All relevant 'using' conversions are converted} -body {
    proc echo {args} {
        return $args
    }

    type dog {
        delegate typemethod tail using {echo %% %t %M %m %j %n %w %s %c}
    }

    dog tail
} -cleanup {
    dog destroy
    rename echo ""
} -result {% ::dog tail tail tail %n %w %s %c}

test dtypemethod-2.3 {"%%" is handled properly} -body {
    proc echo {args} { join $args "|" }

    type dog {
        delegate typemethod wag using {echo %%m %%%m}
    }

    dog wag
} -cleanup {
    dog destroy
    rename echo ""
} -result {%m|%wag}

test dtypemethod-2.4 {Method "*" and "using"} -body {
    proc echo {args} { join $args "|" }

    type dog {
        delegate typemethod * using {echo %m}
    }

    list [dog wag] [dog bark loudly]
} -cleanup {
    dog destroy
    rename echo ""
} -result {wag bark|loudly}

test dtypemethod-3.1 {typecomponent names can be changed dynamically} -body {
    proc echo {args} { join $args "|" }

    type dog {
        delegate typemethod length to mycomp

        typeconstructor {
            set mycomp string
        }

        typemethod switchit {} {
            set mycomp echo
        }
    }

    set a [dog length foo]
    dog switchit
    set b [dog length foo]

    list $a $b
} -cleanup {
    dog destroy
    rename echo ""
} -result {3 length|foo}

test dtypemethod-4.4 {redefinition is OK} -body {
    type wag {
        method tail    {} {return "wags tail"}
        method briskly {} {return "wags tail briskly"}
    }

    type dog {
        typeconstructor {
            set wag [wag #auto]
        }
        delegate typemethod tail to wag as tail
        delegate typemethod tail to wag as briskly
    }

    dog tail
} -cleanup {
    dog destroy
    wag destroy
} -result {wags tail briskly}

#---------------------------------------------------------------------
# Clean up

::tcltest::cleanupTests
return
